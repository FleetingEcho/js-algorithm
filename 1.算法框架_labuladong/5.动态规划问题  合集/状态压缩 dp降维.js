/* 
https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zhuang-tai-ya-suo-ji-qiao

! 你看我们对 dp[i][j] 的更新，
! 其实只依赖于 dp[i+1][j-1], dp[i][j-1], dp[i+1][j] 这三个状态：

! 状态压缩的核心思路就是，将二维数组「投影」到一维数组：
你也看到了，使用状态压缩技巧对二维 dp 数组进行降维打击之后，解法代码的可读性变得非常差了，
如果直接看这种解法，任何人都是一脸懵逼的。
* 算法的优化就是这么一个过程，
* 先写出可读性很好的暴力递归算法，然后尝试运用动态规划技巧优化重叠子问题，最后尝试用状态压缩技巧优化空间复杂度。
也就是说，你最起码能够熟练运用我们前文 动态规划框架套路详解 的套路找出状态转移方程，
写出一个正确的动态规划解法，然后才有可能观察状态转移的情况，分析是否可能使用状态压缩技巧来优化。
希望读者能够稳扎稳打，层层递进，对于这种比较极限的优化，不做也罢。毕竟套路存于心，走遍天下都不怕！

*/
// ! 用最长回文子序列 举例：

//! 最开始的代码是：
for (let i = n - 2; i >= 0; i--) {
  for (let j = i + 1; j < n; j++) {
      // 状态转移方程
      // 在这里，一维 dp 数组中的数是什么？
      if (s[i] == s[j])
          dp[i][j] = dp[i + 1][j - 1] + 2;
      else
          dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
  }
}
/* 
在代码中注释的位置，将要进行状态转移，更新 dp[j]，那么我们要来思考两个问题：
1、在对 dp[j] 赋新值之前，dp[j] 对应着二维 dp 数组中的什么位置？
  答: 在对 dp[j] 赋新值之前，dp[j] 的值就是外层 for 循环上一次迭代算出来的值，
      也就是对应二维 dp 数组中 dp[i+1][j] 的位置。
2、dp[j-1] 对应着二维 dp 数组中的什么位置？
  答: dp[j-1] 的值就是内层 for 循环上一次迭代算出来的值，
      也就是对应二维 dp 数组中 dp[i][j-1] 的位置。

如此以来， 只剩下二维 dp 数组中的 dp[i+1][j-1] 这个状态我们不能直接从一维 dp 数组中得到：

因为 for 循环遍历 i 和 j 的顺序为从左向右，从下向上，所以可以发现，在更新一维 dp 数组的时候，
dp[i+1][j-1] 会被 dp[i][j-1] 覆盖掉，图中标出了这四个位置被遍历到的次序：

那么如果我们想得到 dp[i+1][j-1]，就必须在它被覆盖之前用一个临时变量 temp 把它存起来，
并把这个变量的值保留到计算 dp[i][j] 的时候。

*/
// ! 降维后
function longestPalindromeSubseq(s) {
  let n = s.length;
  // base case：一维 dp 数组全部初始化为 0
  let dp=new Array(n).fill(1);
  for (let i = n - 2; i >= 0; i--) {
      let pre = 0;
      for (let j = i + 1; j < n; j++) {
          let temp = dp[j];
          // 状态转移方程
          if (s[i] == s[j])
              dp[j] = pre + 2;
          else
              dp[j] = Math.max(dp[j], dp[j - 1]);
          pre = temp;
      }
  }
  return dp[n - 1];
}
