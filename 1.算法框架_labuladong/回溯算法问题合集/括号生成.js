/* 

括号问题可以简单分成两类，一类是前文写过的 括号的合法性判断 ，
一类是合法括号的生成。对于括号合法性的判断，
主要是借助「栈」这种数据结构，而对于括号的生成，
一般都要利用回溯递归的思想。
*/
// ! 对于递归相关的算法，时间复杂度这样计算（递归次数）*（递归函数本身的时间复杂度）。

/* 
我们前面怎么分析动态规划算法的递归次数的？
主要是看「状态」的个数对吧。其实回溯算法和动态规划的本质都是穷举，
只不过动态规划存在「重叠子问题」可以优化，而回溯算法不存在而已

*/
/* 
比如说，输入 n=3，输出为如下 5 个字符串：
"((()))", "(()())", "(())()", "()(())", "()()()"



1、一个「合法」括号组合的左括号数量一定等于右括号数量，
2、对于一个「合法」的括号字符串组合 p，
必然对于任何 0 <= i < len(p) 都有：
 子串 p[0..i] 中左括号的数量都大于或等于右括号的数量。
*/

/* 
算法输入一个整数 n，让你计算 n 对儿括号能组成几种合法的括号组合，可以改写成如下问题：
现在有 2n 个位置，每个位置可以放置字符 ( 或者 )，
组成的所有括号组合中，有多少个是合法的？

>　回溯算法套路

result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择

*/

/* 
> 剪枝的关键：
对于 2n 个位置，必然有 n 个左括号，n 个右括号，
所以我们不是简单的记录穷举位置 i，
而是用 left 记录还可以使用多少个左括号，
用 right 记录还可以使用多少个右括号，这样就可以通过刚才总结的合法括号规律进行筛选了：

*/

function generateParenthesis(n) {
  if (n == 0) return {};
  // 记录所有合法的括号组合
  let res=[];
  // 回溯过程中的路径
  let track=[];
  // 可用的左括号和右括号数量初始化为 n
  backtrack(n, n, track, res);
  return res;
}

// 可用的左括号数量为 left 个，可用的右括号数量为 right 个
function backtrack(left, right, track,  res) {
  // 若左括号剩下的多，说明不合法
  if (right < left) return;
  // 数量小于 0 肯定是不合法的
  if (left < 0 || right < 0) return;
  // 当所有括号都恰好用完时，得到一个合法的括号组合
  if (left == 0 && right == 0) {
      res.push(Array.from(track).join(""));
      return;
  }

  // 尝试放一个左括号
  track.push('('); // 选择
  backtrack(left - 1, right, track, res);
  track.pop(); // 撤消选择

  // 尝试放一个右括号
  track.push(')') // 选择
  backtrack(left, right - 1, track, res);
  track.pop(); // 撤消选择
}

// [ '((()))', '(()())', '(())()', '()(())', '()()()' ]
console.log(generateParenthesis(3));