/* 
给你一个可装载重量为W的背包和N个物品，每个物品有重量和价值两个属性。
其中第i个物品的重量为wt[i]，价值为val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

举个简单的例子，输入如下：

N = 3, W = 4     
wt = [2, 1, 3]     重量
val = [4, 2, 3]    价值
算法返回 6，选择前两件物品装进背包，总重量 3 小于W，可以获得最大价值 6
*/

// ! 动态规划问题
/* 
! 1.要明确两点，「状态」和「选择」。
状态有两个，就是「背包的容量」和「可选择的物品」。
选择就是「装进背包」或者「不装进背包」嘛。

! 2.明确该问题 dp数组的定义
* dp数组是什么？其实就是描述问题局面的一个数组。
* 换句话说，我们刚才明确问题有什么「状态」，现在需要用dp数组把状态表示出来。
* 有两个状态， 所以需要用二维数组表示
* 需要一个二维dp数组，一维表示可选择的物品，一维表示背包的容量。
* dp[i][w]的定义如下：对于前i个物品，当前背包的容量为w，这种情况下可以装的最大价值是dp[i][w]。
*   比如说，如果 dp[3][5] = 6，其含义为：对于给定的一系列物品中，
*   若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。

! 根据这个定义，我们想求的最终答案就是dp[N][W]。
!base case 就是dp[0][..] = dp[..][0] = 0，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。

! 3. 根据「选择」，思考状态转移的逻辑。

* 不装第i个物品，那么很显然，最大价值dp[i][w]应该等于dp[i-1][w]。你不装，那就继承之前的结果。
* 装入第i个物品，那么dp[i][w]应该等于dp[i-1][w-wt[i-1]] + val[i-1]。
*/

function knapsack(W, N, wt,val) {
  // vector 全填入 0，base case 已初始化
  let dp = new Array(N+1).fill(0).map(v=>new Array(W+1).fill(0));//边界也全用0填满即可
  for (let i = 1; i <= N; i++) {
      for (let w = 1; w <= W; w++) {
          if (w - wt[i-1] < 0) {
              // 当前背包容量装不下，只能选择不装入背包
              dp[i][w] = dp[i - 1][w];
          } else {
              // 装入或者不装入背包，择优
              dp[i][w] = Math.max(dp[i - 1][w - wt[i-1]] + val[i-1], //价值
                             dp[i - 1][w]);
          }
      }
  }

  return dp[N][W];//最后一位就是最优解
}






