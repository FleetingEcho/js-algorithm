// 556. 下一个更大元素 III
/* 
给定一个32位正整数 n，你需要找到最小的32位整数，其与 n 中存在的位数完全相同，并且其值大于n。如果不存在这样的32位整数，则返回-1。

示例 1:

输入: 12
输出: 21
示例 2:

输入: 21
输出: -1

1、从低位到高位，如果每位数字是依次递增的，那么就不存在符合题意的数，比如44332211。

2、需要从低位到高位遍历，判断是否能找到一个比高位某数更大的最小值。以12443111为例，
可以发现低位的3是比高位的2大的最小值(4也比2大，但不是最小值)，那么可以将3和2进行交换，
得到13442111，然后再把4以后的数按从小到大的顺序进行排列即可，答案为13111244.

3、怎样找到比低位大的最小值呢？可以考虑使用栈，从后往前，维持一个递增栈，
当遇到小于栈顶的元素时(索引为i)，依次出栈，并将栈顶元素的索引保存下来，
从而找到低位比当前元素大的最小值所在的位置idx，将两个元素交换。
然后从i+ 1开始，进行从小到大排序。即可得到答案。

*/

// 维护单调递增的栈

function nextGreaterElement(n) {
	let res = 0
	let q = []
	let str = Array.from(String(n)) //字符串数组

	for (let i = str.length - 1; i >= 0; i--) {
		if (q.length === 0 || str[i] >= q[q.length - 1]) q.push(str[i])
		else {
			let count = 0
			// 出栈，记录出栈的位数
			while (q.length !== 0 && str[i] < q[q.length - 1]) {
				q.pop()
				count++
			}
			;[str[i], str[i + count]] = [str[i + count], str[i]] // swap元素
			res = parseInt(
				str.slice(0, i + 1).join('') +
					str
						.slice(i + 1)
						.reverse()
						.join('')
			) // 反转右边
			return res >= 2 ** 31 - 1 ? -1 : res
		}
	}

	return -1
}
