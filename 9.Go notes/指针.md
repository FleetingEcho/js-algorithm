```go
指针是一个特殊的变量,它里面存储的是另一个变量的内存地址，&操作符获取变量地址，*操作符获取指针指向的变量的值
只声明未赋值的指针，默认值为nil 没有分配内存 不可取值
函数方法的接受者，是指针变量时候，指针会被拷贝传入方法中，拷贝的指针，其指向的地方与原有指针一样，所以可以修改原始变量


何时使用:

不要对 map、slice、channel 这类引用类型使用指针；
如果需要修改方法接收者内部的数据或者状态时，需要使用指针；
如果需要修改参数的值或者内部数据时，也需要使用指针类型的参数；
如果是比较大的结构体，每次参数传递或者调用方法都要内存拷贝，内存占用多，这时候可以考虑使用指针；
像 int、bool 这样的小数据类型没必要使用指针；
如果需要并发安全，则尽可能地不要使用指针，使用指针一定要保证并发安全；
指针最好不要嵌套，也就是不要使用一个指向指针的指针，虽然 Go 语言允许这么做，但是这会使代码变得异常复杂。

package main

import "fmt"

func main() {
//  &取地址符 例如：{指针}:=&{变量}
//  *取值符 例如：{变量}:=*{指针}

    var ptr *string // 声明指针 初始值为nil
	a := 1
	b := 2
	swap(a, b) // 值传递
	fmt.Println(a, ",", b) // 输出1,2
	swapPoint(&a, &b) // 指针传递 使用&获取变量地址
	fmt.Println(a, ",", b) // 输出 2,1
	// 空指针判断
	if(ptr != nil)    /* ptr 不是空指针 */
    if(ptr == nil)    /* ptr 是空指针 */
}

func swap(a, b int) {
	t := a
	a = b
	b = t
}

func swapPoint(a, b *int) {
	t := *a // 获取a指针指向的变量 赋给t
	*a = *b // 将b指针指向的变量的值 赋给 a指针指向的变量
	*b = t  // 将t的值 赋给b指针指向的变量
}


```
